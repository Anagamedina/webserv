<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Webserv: TcpListener Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Webserv
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">Servidor HTTP en C++98 compatible con NGINX</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classTcpListener.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classTcpListener-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">TcpListener Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="TcpListener_8hpp_source.html">TcpListener.hpp</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Collaboration diagram for TcpListener:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="classTcpListener__coll__graph.svg" width="138" height="218"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aebf13c12d799c4a3d2399112c079bb8c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTcpListener.html#aebf13c12d799c4a3d2399112c079bb8c">TcpListener</a> (const std::string &amp;host, int port)</td></tr>
<tr class="separator:aebf13c12d799c4a3d2399112c079bb8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa7fbd89ffb8dc50390cb08d6bdf5bec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTcpListener.html#aaa7fbd89ffb8dc50390cb08d6bdf5bec">~TcpListener</a> ()</td></tr>
<tr class="separator:aaa7fbd89ffb8dc50390cb08d6bdf5bec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dd53220fc8eeed06e73f9f10989cb6b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTcpListener.html#a8dd53220fc8eeed06e73f9f10989cb6b">listen</a> ()</td></tr>
<tr class="separator:a8dd53220fc8eeed06e73f9f10989cb6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9028a8ba1496897435ca46bc715ccdaf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTcpListener.html#a9028a8ba1496897435ca46bc715ccdaf">acceptConnection</a> (std::string &amp;clientIp)</td></tr>
<tr class="separator:a9028a8ba1496897435ca46bc715ccdaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c13bb500eb3195e7cac7acb78faf1ee"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTcpListener.html#a2c13bb500eb3195e7cac7acb78faf1ee">getFd</a> () const</td></tr>
<tr class="separator:a2c13bb500eb3195e7cac7acb78faf1ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa262452852ad73bbec5f79b30ba74a52"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTcpListener.html#aa262452852ad73bbec5f79b30ba74a52">getPort</a> () const</td></tr>
<tr class="separator:aa262452852ad73bbec5f79b30ba74a52"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ad4411df41b572163c161a07ebb298dec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTcpListener.html#ad4411df41b572163c161a07ebb298dec">createSocket</a> ()</td></tr>
<tr class="separator:ad4411df41b572163c161a07ebb298dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d157b2c9038e3e606468cf28ebf243d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTcpListener.html#a9d157b2c9038e3e606468cf28ebf243d">setSocketOptions</a> ()</td></tr>
<tr class="separator:a9d157b2c9038e3e606468cf28ebf243d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9df83892cd21ec97627bcdec8b5eba6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTcpListener.html#ab9df83892cd21ec97627bcdec8b5eba6">bindSocket</a> ()</td></tr>
<tr class="separator:ab9df83892cd21ec97627bcdec8b5eba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7622376d5d5b26a5aa31d0bcfb4c7ee6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTcpListener.html#a7622376d5d5b26a5aa31d0bcfb4c7ee6">TcpListener</a> (const <a class="el" href="classTcpListener.html">TcpListener</a> &amp;)</td></tr>
<tr class="separator:a7622376d5d5b26a5aa31d0bcfb4c7ee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4381703e6721148caa80cd9553e557f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTcpListener.html">TcpListener</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTcpListener.html#a4381703e6721148caa80cd9553e557f2">operator=</a> (const <a class="el" href="classTcpListener.html">TcpListener</a> &amp;)</td></tr>
<tr class="separator:a4381703e6721148caa80cd9553e557f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a504c2372eefbd9b885d6bf351b4ff796"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTcpListener.html#a504c2372eefbd9b885d6bf351b4ff796">socket_fd_</a></td></tr>
<tr class="separator:a504c2372eefbd9b885d6bf351b4ff796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a7a68b79161d21785396adf631b0b0a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTcpListener.html#a9a7a68b79161d21785396adf631b0b0a">port_</a></td></tr>
<tr class="separator:a9a7a68b79161d21785396adf631b0b0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecacb0ae9e40bb31b246f1fd234d9812"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTcpListener.html#aecacb0ae9e40bb31b246f1fd234d9812">host_</a></td></tr>
<tr class="separator:aecacb0ae9e40bb31b246f1fd234d9812"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aebf13c12d799c4a3d2399112c079bb8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebf13c12d799c4a3d2399112c079bb8c">&#9670;&nbsp;</a></span>TcpListener() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TcpListener::TcpListener </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div id="dynsection-1" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-1-trigger" src="closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="classTcpListener_aebf13c12d799c4a3d2399112c079bb8c_cgraph.svg" width="608" height="139"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="aaa7fbd89ffb8dc50390cb08d6bdf5bec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa7fbd89ffb8dc50390cb08d6bdf5bec">&#9670;&nbsp;</a></span>~TcpListener()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TcpListener::~TcpListener </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7622376d5d5b26a5aa31d0bcfb4c7ee6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7622376d5d5b26a5aa31d0bcfb4c7ee6">&#9670;&nbsp;</a></span>TcpListener() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TcpListener::TcpListener </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTcpListener.html">TcpListener</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9028a8ba1496897435ca46bc715ccdaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9028a8ba1496897435ca46bc715ccdaf">&#9670;&nbsp;</a></span>acceptConnection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TcpListener::acceptConnection </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>clientIp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Accepts a pending client connection from the accept queue.</p>
<p>Extracts the first completed connection from the kernel's accept queue (populated by <a class="el" href="classTcpListener.html#a8dd53220fc8eeed06e73f9f10989cb6b">listen()</a>) and creates a new socket for bidirectional communication with the client. The original listening socket remains active to accept additional connections.</p>
<p>Accept mechanics:</p>
<ol type="1">
<li>Kernel state before accept():<ul>
<li>Listening socket: fd 3, state TCP_LISTEN, queue: [conn1, conn2, ...]</li>
<li>Each queued connection has completed the TCP three-way handshake</li>
<li><a class="el" href="classClient.html">Client</a> connections waiting to be extracted by the application</li>
</ul>
</li>
<li>accept() operation:<ul>
<li>Dequeues the oldest connection from the accept queue (FIFO)</li>
<li>Allocates a NEW socket (distinct file descriptor)</li>
<li>Copies peer address into client_addr (IP + ephemeral port)</li>
<li>Returns new socket fd in ESTABLISHED state</li>
</ul>
</li>
<li>After accept():<ul>
<li>Listening socket: fd 3, remains in TCP_LISTEN (unchanged)</li>
<li>New socket: fd N, state TCP_ESTABLISHED, connected to specific client</li>
<li>Two independent sockets: one listens, one communicates</li>
</ul>
</li>
</ol>
<p>Non-blocking behavior:</p>
<ul>
<li>Accept queue empty: → accept() returns -1 immediately → errno set to EAGAIN or EWOULDBLOCK → Caller must retry after epoll_wait() indicates readiness</li>
<li>Accept queue has connections: → accept() returns instantly with client_fd → No blocking, even if new connections arrive concurrently</li>
</ul>
<p>Why O_NONBLOCK on the new socket is CRITICAL:</p>
<ul>
<li>accept() does NOT inherit flags from the listening socket</li>
<li>New client_fd starts in blocking mode (kernel default)</li>
<li>Without fcntl(O_NONBLOCK): read/write on client_fd would block</li>
<li>Consequence: one slow client stalls the entire server</li>
</ul>
<p>Implementation: fcntl() read–modify–write pattern</p><ul>
<li>F_GETFL: read current flags (preserves O_LARGEFILE, etc.)</li>
<li>OR with O_NONBLOCK: atomically add flag</li>
<li>F_SETFL: write modified flags back</li>
</ul>
<p>Alternative (Linux ≥ 2.6.28):</p><ul>
<li>accept4(fd, addr, len, SOCK_NONBLOCK | SOCK_CLOEXEC)</li>
<li>Reason not used: portability; POSIX compliance</li>
</ul>
<p>sockaddr_in extraction:</p>
<ol type="1">
<li>sin_addr.s_addr: <a class="el" href="classClient.html">Client</a> IP address in network byte order (big-endian).<ul>
<li>Example: 192.168.1.100 → 0xC0A80164 in memory</li>
<li>inet_ntop() converts to human-readable "192.168.1.100"</li>
</ul>
</li>
<li>sin_port: <a class="el" href="classClient.html">Client</a> ephemeral port in network byte order.<ul>
<li>Range: 32768–60999 (Linux default /proc/sys/net/ipv4/ip_local_port_range)</li>
<li>ntohs() converts to host order for logging</li>
</ul>
</li>
<li>addr_len (value-result parameter):<ul>
<li>Input: size of client_addr buffer</li>
<li>Output: actual size written (unchanged for IPv4)</li>
<li>Needed for IPv6 (larger sockaddr_in6) or protocol flexibility</li>
</ul>
</li>
</ol>
<p>Security considerations:</p>
<ul>
<li>bzero() before use: ensures uninitialized memory doesn't leak</li>
<li>inet_ntop() with INET_ADDRSTRLEN: buffer overflow protection</li>
<li>Failed fcntl() doesn't abort: graceful degradation</li>
</ul>
<p>Why client IP/port logging is useful:</p><ul>
<li>Debugging: correlate requests with specific clients</li>
<li>Security: identify attack sources (rate limiting, ban lists)</li>
<li>Analytics: geographic distribution, connection patterns</li>
</ul>
<p>Error conditions and handling:</p>
<ul>
<li>accept() returns -1: → EAGAIN/EWOULDBLOCK: no connections available (non-blocking) → EMFILE/ENFILE: process/system file descriptor limit reached → ENOMEM: kernel out of memory → EINTR: interrupted by signal (handled by retry) → Function returns -1; caller must check and handle</li>
<li>fcntl() failure: → <a class="el" href="classClient.html">Client</a> socket remains blocking (degraded, but functional) → Server can still communicate; performance impact only → Silent failure (no exception); logged implicitly</li>
</ul>
<p>Resource management:</p>
<ul>
<li>Caller MUST close(client_fd) when done</li>
<li>Failure to close causes file descriptor leak</li>
<li>Leak consequence: eventually hits EMFILE → server stops accepting</li>
</ul>
<p>State after successful accept():</p><ul>
<li>Listening socket: UNCHANGED, can accept more connections</li>
<li>New socket: fd = client_fd, state = ESTABLISHED, peer = client_addr</li>
<li>TCP connection: fully established, ready for send/recv <pre class="fragment">  -1 on failure (check errno: EAGAIN, EMFILE, ENOMEM, etc.) 
</pre> </li>
</ul>
<div id="dynsection-2" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-2-trigger" src="closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-2-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-2-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="classTcpListener_a9028a8ba1496897435ca46bc715ccdaf_icgraph.svg" width="627" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ab9df83892cd21ec97627bcdec8b5eba6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9df83892cd21ec97627bcdec8b5eba6">&#9670;&nbsp;</a></span>bindSocket()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TcpListener::bindSocket </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Binds the socket to a specific port on all network interfaces.</p>
<p>Associates the socket with a local address (IP + port) so the kernel knows where to route incoming connections. Uses sockaddr_in structure for IPv4 addressing.</p>
<p>Address configuration:</p>
<ol type="1">
<li>sin_family = AF_INET: Specifies IPv4 address family (matches socket() domain)</li>
<li><p class="startli">sin_addr.s_addr = INADDR_ANY (0.0.0.0): Listens on ALL network interfaces simultaneously:</p><ul>
<li>lo (127.0.0.1): localhost connections</li>
<li>eth0 (192.168.1.X): LAN connections</li>
<li>wlan0 (10.0.0.X): WiFi connections</li>
</ul>
<p class="startli">Alternative not used:</p><ul>
<li>Specific IP (e.g., inet_addr("127.0.0.1")): restricts to one interface</li>
<li>Reason: server must be externally accessible</li>
</ul>
</li>
<li><p class="startli">sin_port = htons(port_): Port number in network byte order (big-endian).</p>
<p class="startli">htons() necessity:</p><ul>
<li>Little-endian (x86): 8080 = 0x1F90 → memory [0x90, 0x1F]</li>
<li>Big-endian (network): 8080 = 0x1F90 → memory [0x1F, 0x90]</li>
<li>TCP/IP standard: network byte order = big-endian (RFC 1700)</li>
<li>htons(): converts host order → network order (no-op on big-endian)</li>
</ul>
<p class="startli">Without conversion: server would listen on port 36895 (0x901F) instead of 8080</p>
</li>
</ol>
<p>Kernel operations on bind():</p><ol type="1">
<li>Verifies port is not in use (unless SO_REUSEADDR)</li>
<li>Registers socket in global port hash table</li>
<li>Socket gains identity: (0.0.0.0:port_)</li>
<li>Subsequent packets to this port route to this socket</li>
</ol>
<p>Error conditions:</p><ul>
<li>EADDRINUSE: port already bound (check SO_REUSEADDR, kill other process)</li>
<li>EACCES: port &lt; 1024 requires root (use port &gt;= 1024)</li>
<li>EINVAL: socket already bound or invalid address</li>
</ul>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if bind() fails </td></tr>
  </table>
  </dd>
</dl>
<div id="dynsection-3" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-3-trigger" src="closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-3-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-3-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="classTcpListener_ab9df83892cd21ec97627bcdec8b5eba6_cgraph.svg" width="359" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div id="dynsection-4" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-4-trigger" src="closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-4-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-4-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="classTcpListener_ab9df83892cd21ec97627bcdec8b5eba6_icgraph.svg" width="383" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ad4411df41b572163c161a07ebb298dec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4411df41b572163c161a07ebb298dec">&#9670;&nbsp;</a></span>createSocket()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TcpListener::createSocket </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a TCP socket for accepting client connections.</p>
<p>Uses AF_INET (IPv4) with SOCK_STREAM (TCP) to establish a reliable, connection-oriented communication channel. When SOCK_STREAM is specified with AF_INET, the kernel automatically selects IPPROTO_TCP.</p>
<p>Socket characteristics:</p><ul>
<li>Ordered delivery: bytes arrive in send order</li>
<li>No duplication: duplicate TCP segments are discarded by the kernel</li>
<li>Flow control: sliding window prevents receiver saturation</li>
<li>Congestion control: TCP Cubic dynamically adjusts the send window</li>
</ul>
<p>Alternatives not used:</p><ul>
<li>AF_INET6: IPv6 not required by the 42 subject</li>
<li>AF_UNIX: local IPC only; not applicable for a web server</li>
<li>SOCK_DGRAM: UDP is unreliable and incompatible with HTTP semantics</li>
</ul>
<p>Returns a file descriptor (typically ≥ 3) representing this socket in the kernel file descriptor table. The initial state is blocking; O_NONBLOCK must be enabled separately via fcntl().</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if socket creation fails (EMFILE, ENFILE, ENOMEM, etc.) </td></tr>
  </table>
  </dd>
</dl>
<div id="dynsection-5" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-5-trigger" src="closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-5-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-5-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="classTcpListener_ad4411df41b572163c161a07ebb298dec_icgraph.svg" width="395" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a2c13bb500eb3195e7cac7acb78faf1ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c13bb500eb3195e7cac7acb78faf1ee">&#9670;&nbsp;</a></span>getFd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TcpListener::getFd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<div id="dynsection-6" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-6-trigger" src="closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-6-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-6-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="classTcpListener_a2c13bb500eb3195e7cac7acb78faf1ee_icgraph.svg" width="395" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="aa262452852ad73bbec5f79b30ba74a52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa262452852ad73bbec5f79b30ba74a52">&#9670;&nbsp;</a></span>getPort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TcpListener::getPort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<div id="dynsection-7" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-7-trigger" src="closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-7-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-7-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="classTcpListener_aa262452852ad73bbec5f79b30ba74a52_icgraph.svg" width="564" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a8dd53220fc8eeed06e73f9f10989cb6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dd53220fc8eeed06e73f9f10989cb6b">&#9670;&nbsp;</a></span>listen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TcpListener::listen </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Activates listening mode on the socket, enabling it to accept connections.</p>
<p>Marks the socket as passive (listening for incoming connections) rather than active (initiating connections). Transitions the socket state from UNCONNECTED to LISTEN.</p>
<p>Backlog parameter: SOMAXCONN</p>
<p>Definition: Maximum size of the accept queue (completed connections).</p><ul>
<li>Typical Linux value: 128 (see /proc/sys/net/core/somaxconn)</li>
<li>Can be increased system-wide via sysctl</li>
</ul>
<p>Purpose: Buffers completed connections that have not yet been accept()'ed, protecting the server from bursts of simultaneous connection attempts.</p>
<p>Linux maintains two internal queues:</p>
<ol type="1">
<li>SYN queue (incomplete connections):<ul>
<li>Connections in TCP handshake (SYN_RECV state)</li>
<li>Size: tcp_max_syn_backlog (default: 256)</li>
<li><a class="el" href="classClient.html">Client</a> sent SYN, server sent SYN-ACK, awaiting final ACK</li>
</ul>
</li>
<li>Accept queue (completed connections):<ul>
<li>Connections in ESTABLISHED state</li>
<li>Size: min(backlog, somaxconn)</li>
<li>Handshake complete; waiting for accept()</li>
<li>Controlled by SOMAXCONN</li>
</ul>
</li>
</ol>
<p>Queue overflow behavior:</p><ul>
<li>Accept queue full and a new connection completes the handshake: → Connection is dropped silently (no RST sent) → <a class="el" href="classClient.html">Client</a> retransmits SYN (interpreting loss) → Provides basic protection against SYN flood attacks</li>
</ul>
<p>Why SOMAXCONN instead of a fixed value:</p>
<ul>
<li>Small value (e.g., 10):<ul>
<li>Issue: burst of 50 connections → 40 dropped</li>
<li>Suitable only for low-traffic internal services</li>
</ul>
</li>
<li>Large value (e.g., 100000):<ul>
<li>Issue: unnecessary memory consumption; facilitates DoS</li>
<li>Suitable use case: none (kernel limits exist for safety)</li>
</ul>
</li>
<li>SOMAXCONN (128):<ul>
<li>Balanced default for typical workloads</li>
<li>Tunable by system administrators via sysctl</li>
<li>Kernel-enforced upper bound limits abuse</li>
</ul>
</li>
</ul>
<p>After <a class="el" href="classTcpListener.html#a8dd53220fc8eeed06e73f9f10989cb6b">listen()</a>, the socket can:</p><ul>
<li>Receive SYN packets from clients</li>
<li>Complete TCP three-way handshakes automatically</li>
<li>Queue established connections for accept()</li>
</ul>
<p>State transition:</p><ul>
<li>Before: bind() → socket bound to 0.0.0.0:8080</li>
<li>After: <a class="el" href="classTcpListener.html#a8dd53220fc8eeed06e73f9f10989cb6b">listen()</a> → socket in TCP_LISTEN state</li>
</ul>
<p>Kernel actions:</p><ol type="1">
<li>Transitions sk-&gt;sk_state to TCP_LISTEN</li>
<li>Allocates the SYN and accept queues</li>
<li>Registers the socket in the listening hash table</li>
<li>Begins processing SYN packets for this port</li>
</ol>
<p>Error conditions:</p><ul>
<li>EADDRINUSE: another socket is already listening on this port</li>
<li>EOPNOTSUPP: socket type does not support <a class="el" href="classTcpListener.html#a8dd53220fc8eeed06e73f9f10989cb6b">listen()</a> (e.g., SOCK_DGRAM)</li>
</ul>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if <a class="el" href="classTcpListener.html#a8dd53220fc8eeed06e73f9f10989cb6b">listen()</a> fails </td></tr>
  </table>
  </dd>
</dl>
<div id="dynsection-8" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-8-trigger" src="closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-8-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-8-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="classTcpListener_a8dd53220fc8eeed06e73f9f10989cb6b_icgraph.svg" width="392" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a4381703e6721148caa80cd9553e557f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4381703e6721148caa80cd9553e557f2">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTcpListener.html">TcpListener</a>&amp; TcpListener::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTcpListener.html">TcpListener</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9d157b2c9038e3e606468cf28ebf243d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d157b2c9038e3e606468cf28ebf243d">&#9670;&nbsp;</a></span>setSocketOptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TcpListener::setSocketOptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Configures socket options for optimal server operation.</p>
<p>Sets two critical flags:</p>
<ol type="1">
<li><p class="startli">SO_REUSEADDR (socket-level option): Allows immediate rebinding to the same port after server restart.</p>
<p class="startli">Problem it solves: TIME_WAIT state</p><ul>
<li>When server closes, TCP enters TIME_WAIT for 2×MSL (~60s on Linux)</li>
<li>Without SO_REUSEADDR: bind() fails with EADDRINUSE</li>
<li>With SO_REUSEADDR: kernel marks TIME_WAIT entry as reusable</li>
</ul>
<p class="startli">Safety considerations:</p><ul>
<li>Safe for servers: same port, different client ephemeral ports</li>
<li>Collision probability of (IP_local, port_local, IP_remote, port_remote) ≈ 0</li>
</ul>
<p class="startli">Level: SOL_SOCKET (generic, not TCP-specific)</p>
</li>
<li><p class="startli">O_NONBLOCK (file status flag): Enables non-blocking I/O on the socket.</p>
<p class="startli">Behavior change:</p><ul>
<li>Blocking (default): read/write/accept suspend execution until ready</li>
<li>Non-blocking: return immediately with EAGAIN/EWOULDBLOCK</li>
</ul>
<p class="startli">Why this is critical:</p><ul>
<li>Single-threaded event loop: one slow client cannot block others</li>
<li>Epoll integration: readiness checked before actual I/O</li>
<li>No process suspension: preserves responsiveness under load</li>
</ul>
<p class="startli">Implementation: fcntl() read–modify–write</p><ul>
<li>F_GETFL: read current flags (preserves O_LARGEFILE, etc.)</li>
<li>OR with O_NONBLOCK: add flag without clearing others</li>
<li>F_SETFL: write modified flags back</li>
</ul>
<p class="startli">Alternative not used:</p><ul>
<li>socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, 0) // Linux ≥ 2.6.27</li>
<li>Reason: portability; read–modify–write is safer</li>
</ul>
</li>
</ol>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if setsockopt() fails (EBADF, ENOPROTOOPT, …) </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if fcntl(F_GETFL) fails </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if fcntl(F_SETFL) fails </td></tr>
  </table>
  </dd>
</dl>
<div id="dynsection-9" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-9-trigger" src="closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-9-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-9-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="classTcpListener_a9d157b2c9038e3e606468cf28ebf243d_icgraph.svg" width="422" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aecacb0ae9e40bb31b246f1fd234d9812"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecacb0ae9e40bb31b246f1fd234d9812">&#9670;&nbsp;</a></span>host_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string TcpListener::host_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9a7a68b79161d21785396adf631b0b0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a7a68b79161d21785396adf631b0b0a">&#9670;&nbsp;</a></span>port_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int TcpListener::port_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a504c2372eefbd9b885d6bf351b4ff796"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a504c2372eefbd9b885d6bf351b4ff796">&#9670;&nbsp;</a></span>socket_fd_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int TcpListener::socket_fd_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/network/<a class="el" href="TcpListener_8hpp_source.html">TcpListener.hpp</a></li>
<li>src/network/<a class="el" href="TcpListener_8cpp.html">TcpListener.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classTcpListener.html">TcpListener</a></li>
    <li class="footer">Generated on Fri Feb 27 2026 18:15:30 for Webserv by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
