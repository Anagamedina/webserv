<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LaserWeb — Carles / The Executor</title>
    <link rel="stylesheet" href="/css/laserweb.css">
</head>
<body>
    <div class="page">
        <header>
            <h1 class="logo">L<span>Λ</span>S<span>Ξ</span>RW<span>Ξ</span>B</h1>
        </header>

        <nav class="nav-hud">
            <a href="/">THE HUD</a>
            <a href="/upload.html">LOAD LASER</a>
            <a href="/squad_staff.html">ELITE SQUAD</a>
            <a href="/cgi-bin/list_images.py">TACTICAL SCANNER</a>
        </nav>

        <main class="panel">
            <h2>Carles Pujades — The Executor</h2>
            <p class="back-row"><a href="/squad_staff.html" class="btn btn-back">&larr; Back to Elite Squad</a></p>

            <p class="page-title">Mission report: Epoll and CGI</p>

            <div class="doc-block">
                <p class="doc-p">
                    This console documents the server's <strong>I/O multiplexing layer (epoll)</strong> and <strong>CGI execution</strong>.
                    Epoll is the radar that monitors all communication channels; CGI is the protocol that fires external scripts like controlled laser shots.
                </p>
            </div>

            <div class="doc-block">
                <h3 class="doc-h3">1. What is Epoll?</h3>
            <p class="doc-p">
                <strong>Epoll</strong> is the Linux kernel mechanism used to wait for events on many file descriptors at once (client sockets, listeners, CGI pipes) without blocking the server. Instead of asking each one \"is there data?\", the kernel notifies: \"this fd has activity\".
            </p>
            <p class="doc-p">
                In LaserWeb, <code>EpollWrapper</code> encapsulates the epoll API: it creates the instance (<code>epoll_create</code>), adds or modifies descriptors (<code>epoll_ctl</code> with <code>EPOLL_CTL_ADD</code> / <code>EPOLL_CTL_MOD</code>), removes them when the connection closes (<code>EPOLL_CTL_DEL</code>) and waits for events with <code>epoll_wait</code>. The main loop of <code>ServerManager</code> calls <code>wait()</code> and, depending on which fd woke up, delegates to \"new connection\", \"client ready to read/write\" or \"CGI pipe output\".
            </p>
            </div>

            <div class="doc-block">
                <h3 class="doc-h3">2. Level Triggered vs Edge Triggered</h3>
                <p class="doc-p">
                    Epoll can notify in two ways: <strong>Level Triggered (LT)</strong> — it keeps notifying while the socket remains ready — or <strong>Edge Triggered (ET)</strong> — it only notifies when the state changes from \"not ready\" to \"ready\". In this project we use <strong>LT</strong>: if you don't read or write everything in one event, epoll will notify again. This avoids lost data and keeps the <code>Client</code> and CGI pipe logic simpler and more stable.
                </p>
            </div>

            <div class="doc-block">
                <h3 class="doc-h3">3. What is CGI and how is it structured?</h3>
                <p class="doc-p">
                <strong>CGI (Common Gateway Interface)</strong> is a standard for executing external programs (scripts or binaries) in response to an HTTP request. The server prepares environment variables (method, URI, headers, etc.), passes the body through stdin to the process and reads the response from stdout (headers + body). In LaserWeb this is done <strong>asynchronously</strong>: we do not block the main loop waiting for the script.
            </p>
            <ul class="target-list">
                <li><strong>CgiExecutor</strong> — Orchestrates the shot: it receives the HTTP request and script path (and optionally the interpreter). It prepares the environment (CGI variables), creates pipes for the child's stdin/stdout, sets them to non-blocking, performs <code>fork</code> and, in the child, redirects stdin/stdout to the pipes and calls <code>execve</code>. It returns a <code>CgiProcess*</code> and the loop continues; the script output is read later when epoll marks the pipe as readable.</li>
                <li><strong>CgiProcess</strong> — Represents a CGI process in progress: it stores the pipe fds, PID, body pending to be sent to the script, the output buffer (headers + body), states (<code>RUNNING</code>, <code>DATA_READY</code>, <code>COMPLETED</code>, <code>FAILED</code>, <code>SENT</code>) and timeout. Methods like <code>appendResponseData</code> accumulate the output and detect the end of headers (<code>\r\n\r\n</code>); the <code>Client</code> writes the body to the input pipe and reads from the output pipe when epoll indicates readiness.</li>
            </ul>
            </div>

            <div class="doc-block">
                <h3 class="doc-h3">4. CGI environment variables</h3>
            <p class="doc-p">
                Before <code>execve</code>, <code>CgiExecutor</code> builds a map with standard variables: <code>REQUEST_METHOD</code>, <code>PATH_INFO</code>, <code>QUERY_STRING</code>, <code>CONTENT_LENGTH</code>, <code>CONTENT_TYPE</code>, <code>SCRIPT_FILENAME</code>, etc. That map is converted to a <code>char*</code> array and passed to the child process so the script behaves like under a real web server.
            </p>
            </div>

            <div class="doc-block">
                <h3 class="doc-h3">5. Integration with the server loop</h3>
            <p class="doc-p">
                When a request must execute a CGI, the <code>Client</code> asks <code>ServerManager</code> to register the CGI output pipe in epoll (<code>registerCgiPipe</code>). When epoll fires for that fd, <code>handleCgiPipeEvent</code> is called and the event is delegated to the associated <code>Client</code> (<code>handleCgiPipe</code>), which reads from the pipe, updates the <code>CgiProcess</code> and, once the CGI response is complete, enqueues it to be sent to the browser. All this without blocking the rest of the connections.
            </p>
            </div>

            <div class="doc-block">
                <p class="doc-p" style="margin:0; color:var(--text-dim); font-size:0.9rem;">
                    Goal: every CGI script should behave like a controlled shot: prepare the environment, execute in a child process, monitor pipes with epoll and collect the output asynchronously, without compromising the stability of the server core.
                </p>
            </div>
        </main>
    </div>
</body>
</html>
